#!/bin/bash

# Parallel Pokémon Data Retrieval Script
# Fetches data for multiple Pokémon from the PokéAPI in parallel
# using background processes and stores each response in pokemon_data/<name>.json

API_BASE_URL="https://pokeapi.co/api/v2/pokemon"
OUTPUT_DIR="pokemon_data"

# Ensure output directory exists
mkdir -p "$OUTPUT_DIR"

# List of Pokémon to fetch
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")

# Error log file
ERROR_LOG="errors.txt"

# Function to fetch a single Pokémon's data
fetch_pokemon() {
    local pokemon=$1
    local output_file="${OUTPUT_DIR}/${pokemon}.json"
    
    echo "Fetching data for ${pokemon}..."
    
    # Make API request
    response=$(curl -s -w "\n%{http_code}" "${API_BASE_URL}/${pokemon}" 2>&1)
    http_code=$(echo "$response" | tail -n1)
    body=$(echo "$response" | sed '$d')
    
    # Check if request was successful
    if [ "$http_code" -eq 200 ] && [ -n "$body" ] && echo "$body" | jq empty 2>/dev/null; then
        echo "$body" > "$output_file"
        echo "Saved data to ${output_file} ✅"
    else
        # Handle different error scenarios
        if [ -z "$http_code" ] || [ "$http_code" = "000" ]; then
            error_msg="Network error: Failed to connect to API"
        elif [ "$http_code" -eq 404 ]; then
            error_msg="Invalid Pokémon name: ${pokemon} not found (HTTP 404)"
        elif [ "$http_code" -ge 500 ]; then
            error_msg="Server error: API returned HTTP ${http_code}"
        else
            error_msg="Request failed: HTTP ${http_code}"
        fi
        
        echo "Failed to fetch data for ${pokemon}: ${error_msg}" >> "$ERROR_LOG"
        echo "Failed to fetch data for ${pokemon}: ${error_msg}" >&2
    fi
}

# Export function so it's available to background processes
export -f fetch_pokemon
export API_BASE_URL OUTPUT_DIR ERROR_LOG

# Cleanup function to kill background jobs on exit
cleanup() {
    echo "Cleaning up background jobs..."
    # Kill all background jobs using jobs command
    jobs -p | while read pid; do
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null
        fi
    done
    wait
}

# Set trap to cleanup on script exit
trap cleanup EXIT INT TERM

# Launch background processes for each Pokémon
for pokemon in "${POKEMON_LIST[@]}"; do
    fetch_pokemon "$pokemon" &
done

# Wait for all background processes to complete
echo "Waiting for all processes to complete..."

# Monitor background jobs using jobs command
while [ $(jobs -r | wc -l) -gt 0 ]; do
    # Check status of background jobs
    jobs > /dev/null 2>&1
    sleep 0.1
done

# Wait for all jobs to complete
wait

# Verify all jobs are done using jobs command
if [ $(jobs -r | wc -l) -eq 0 ]; then
    echo "All Pokémon data fetching completed."
    # Disable trap since we completed successfully
    trap - EXIT INT TERM
else
    echo "Warning: Some background jobs may still be running"
    jobs
    # Kill any remaining jobs
    jobs -p | while read pid; do
        kill "$pid" 2>/dev/null
    done
fi

